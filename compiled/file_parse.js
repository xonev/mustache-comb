// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, FileParse, MustacheTransformer, fs, sax,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  MustacheTransformer = require('./mustache_transformer').MustacheTransformer;

  fs = require('fs');

  sax = require('sax');

  FileParse = (function(_super) {

    __extends(FileParse, _super);

    function FileParse(filepath) {
      this.filepath = filepath;
      FileParse.__super__.constructor.call(this);
      this.errors = [];
      this.openElements = {};
      this.parser = null;
      this.transformer = new MustacheTransformer;
    }

    FileParse.prototype.run = function() {
      var fileStream,
        _this = this;
      this.parser = this.parser || sax.createStream(true);
      this.parser.on('error', function(error) {
        var errorObj;
        errorObj = _this.parseError(error.message);
        return console.log("" + _this.filepath + ":" + errorObj.line + ": Parsing error: " + errorObj.message);
      });
      this.parser.on('opentag', function(tag) {
        var name;
        name = tag.name;
        if (_this.openElements[name] == null) {
          _this.openElements[name] = 0;
        }
        return _this.openElements[name]++;
      });
      this.parser.on('closetag', function(name) {
        return _this.openElements[name]--;
      });
      this.parser.on('end', function() {
        var count, element, elementText, _ref, _results;
        _ref = _this.openElements;
        _results = [];
        for (element in _ref) {
          count = _ref[element];
          if (count > 0) {
            elementText = count === 1 ? 'element has' : 'elements have';
            _results.push(console.log("" + _this.filepath + ": " + count + " '" + element + "' " + elementText + " not been closed."));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      fileStream = fs.createReadStream(this.filepath);
      return fileStream.pipe(this.transformer).pipe(this.parser);
    };

    FileParse.prototype.parseError = function(error) {
      var matches, newError;
      matches = error.match(/^([^\n]*)\nLine: (\d+)\n/);
      newError = {
        message: '',
        line: null
      };
      if (matches) {
        newError.message = matches[1];
        newError.line = matches[2];
      }
      return newError;
    };

    return FileParse;

  })(EventEmitter);

  exports.FileParse = FileParse;

}).call(this);
